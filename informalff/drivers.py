import os                # To navigate the file system
import shutil            # To do some operation over the file system
import time              # A way to keep track of time
import json              # To parse json files
import warnings          # To throw warnings instead of raising errors
from subprocess import run # Method to run external commands
from multiprocessing import Pool # To parallelize jobs
from abc import ABC, abstractmethod # To be able to create several drivers
from .molecule import Molecule
from .collection import Collection

class QM_driver(ABC):
    """ Factory class for all QM drivers
    
    This class is just supposed to work as a base
    class for other drivers. The immportant methods are
    the constructor and the execute methods.
    """

    def __init__(self):
        pass

    @abstractmethod
    def create_input(self) -> str:
        """ Abstract method to create the input files for the QM calculation
        
        This method is supposed to create the input file(s) required
        for the QM calculation. The path to the directory where the
        input files have been placed should be returned.
        
        Returns
        -------
        work : str
            The path to the directory where the input files have been
            placed, and where the QM calculation should be executed
        """
        pass

    @abstractmethod
    def run_calculation(self, wd : str) -> None:
        """ Abstract method to run the QM calculation
        
        This method is supposed to run the actual QM calculation
        using the input file created by create_input and located
        at the working directory provided as argument.
        
        Parameters
        ----------
        wd : str
            The path to the directory where the input file has been
            placed, and where the QM calculation should be executed
        """
        pass

    @abstractmethod
    def parse_output(self, wd : str) -> dict:
        """ Abstract method to parse the output files of the QM calculation
        
        This method is supposed to read the output files generated by
        the QM calculation and return a dictionary with the parsed
        values.
        
        Parameters
        ----------
        wd : str
            The path to the directory where the output files are
            located
        
        Returns
        -------
        results : dict
            A dictionary with the parsed values from the output
            files
        """
        pass

    def execute(self) -> dict:
        """ Method to execute a QM calculation
        
        This method will do a QM calculation from start to
        finish, including generating the input files, and
        parsing the output files.

        Returns
        -------
        result : dict
            A dictionary with all the results of the QM
            calculation
        """
        # Preparing and creating the input files
        path = self.create_input()
        
        # Run the calculation
        self.run_calculation(path)
        
        # Parse the results from the calculation
        result = self.parse_output(path)

        return result

class ORCA_driver(QM_driver):
    """ Class to run QM calculations in ORCA
    
    Attriutes
    ---------
    orca_path : str
        The path of the Orca executable, including the executable itself
    props : dict
        The properties of the calculation:
            - method: level of theory
            - basis: basis set to be used
            - charge: total charge of the system
            - multipl: multiplicity of the system
            - modifiers: type of calculation, hardware specs, etc.
    mol : Molecule
        A molecule which will save an XYZ file to be used by Orca for the
        calculation
    """

    def __init__(self,
                 path : str,
                 qm_props : dict,
                 mol : Molecule):
        """ ORCA_driver constructor method
        
        Parameters
        ----------
        path : str
            The path of the Orca executable, including the executable itself
        qm_props : dict
            The calculation's properties (e.g. level of theory, basis set)
        mol : Molecule
            A Molecule object to create the inputs for Orca
        """
        self.orca_path = path
        self.props = qm_props
        self.molecule = mol        
    
    def create_input(self) -> str:
        """ Method to create the input files for the Orca calculation
        
        Returns
        -------
        work : str
            The path to the directory where the input files have been
            placed, and where the Orca calculation should be executed
        """
        # First line(s) of the Orca input file
        header = (f'! {self.props["method"]} {self.props["basis"]}'
                  f' {self.props["modifiers"]}\n')
        
        # Specifying the name of the XYZ file, ...
        # ... its charge and multiplicity
        geom = (f'*xyzfile {self.props["charge"]} '
                f'{self.props["multipl"]} geometry.xyz\n')
        
        # Renaming the molecule as "geometry"
        self.molecule.name = "geometry"

        # Get the current working directory, and creating the directory
        # for the Orca calculation
        here = os.getcwd()
        work = os.path.join(here, f'Orca_calculation_{int(time.time())}')
        if os.path.exists(work):
            shutil.rmtree(work)
        os.mkdir(work)
        os.chdir(work)

        # Saving the input file
        with open('input.inp', 'w') as f:
            f.write(header + geom)

        # Saving the geometry as an XYZ file
        self.molecule.save_as_xyz()

        # Return to the base directory
        os.chdir(here)
        return work
    
    def run_calculation(self, wd : str) -> None:
        """ Method to actually run the Orca calculation
        
        Raises
        ------
        ChildProcessError
            If the Orca calculation does not end correctly
        
        Parameters
        ----------
        wd : str
            The path of the directory where the Orca calculation
            should be performed
        """
        
        # Create the paths to both input and output files
        inp = os.path.join(wd, 'input.inp')
        out = os.path.join(wd, 'output.out')

        # Switch to the working directory
        os.chdir(wd)

        # Run the calculation
        with open(out, 'w') as g:
            orca_run = run([self.orca_path, inp], stdout=g)
        
        # Switch back to the base directory
        os.chdir(os.path.join(wd, '..'))
        
        # Complain if the process was not finished correctly
        if orca_run.returncode != 0:
            raise ChildProcessError("ORCA_driver.run_calculation() "
                    "Orca didn't finish the calculation correctly!")
    
    def parse_output(self, wd : str) -> dict:
        """ Method to parse the output file from Orca
        
        Parameters
        ----------
        wd : str
            The path of the directory where the Orca calculation
            should be performed
        
        Returns
        -------
        result : dict
            A dictionary with all the results of the Orca
            calculation
        """
        # Create the path to the output file
        out = os.path.join(wd, 'output.out')
        
        # Empty dictionary to store the results
        results = {}

        # Creating empty Molecule object
        results['Geometry'] = Molecule(self.molecule.name)
        # Loading the information from the XYZ file
        results['Geometry'].read_xyz(os.path.join(wd, 'geometry.xyz'))
        # Creating an empty dictionary for the charges
        results['Charges'] = {}

        # Open the output file and get the data
        with open(out, 'r') as h:
            data = h.readlines()

        # Iterate over all lines
        for i, l in enumerate(data):
            
            # Parse the electronic energy
            if 'FINAL SINGLE POINT ENERGY' in l:
                temp = l.split()
                results['Energy[SPE]'] = float(temp[-1])

            # Parse the orbital energies
            if 'ORBITAL ENERGIES' in l:
                orb_energs = []
                for j in range(self.molecule.get_num_atoms() * 5):
                    try:
                        temp = data[i + 4 + j].split()
                        temp = [
                            float(temp[1]),
                            float(temp[2])
                            ]
                        orb_energs.append(temp)
                    except (ValueError, IndexError) as e:
                        break
                results['OrbitalEnergies[Eh]'] = orb_energs

            # Parse the Mulliken charges
            if 'MULLIKEN ATOMIC CHARGES' in l:
                results['Charges']['Mulliken'] = []
                for j in range(self.molecule.get_num_atoms()):
                    temp = data[i + 2 + j].split()
                    results['Charges']['Mulliken'].append([
                                                        temp[1],
                                                        float(temp[3])
                                                        ])

            # Parse the Loewding charges
            if 'LOEWDIN ATOMIC CHARGES' in l:
                results['Charges']['Loewdin'] = []
                for j in range(self.molecule.get_num_atoms()):
                    temp = data[i + 2 + j].split()
                    results['Charges']['Loewdin'].append([
                                                        temp[1],
                                                        float(temp[3])
                                                        ])
            
            # Parse the dipole moment
            if 'Total Dipole Moment' in l:
                temp = l.split()
                results['Dipole[Debye]'] = [ float(j) for j in temp[4:] ]

        return results

class PSI4_driver(QM_driver):
    """ Class to run QM calculations in Psi4
    
    Attriutes
    ---------
    psi4_path : str
        The path of the Psi4 executable, including the executable itself
    props : dict
        The properties of the calculation:
            - method: level of theory
            - basis: basis set to be used
            - charge: total charge of the system
            - multipl: multiplicity of the system
            - modifiers: type of calculation, hardware specs, etc.
    mol : Molecule
        A molecule which will save an XYZ file to be used by Psi4 for the
        calculation
    """

    def __init__(self,
                 qm_props : dict,
                 mol : Molecule):
        """ PSI4_driver constructor method
        
        Parameters
        ----------
        qm_props : dict
            The calculation's properties (e.g. level of theory, basis set)
        mol : Molecule
            A Molecule object to create the inputs for Psi4
        """
        try:
            import psi4
        except ImportError:
            raise ImportError("Psi4_driver requires psi4 to be installed!")
        
        self.props = qm_props
        self.molecule = mol

        self.psi4_geom = ''
    
    def create_input(self) -> None:
        """ Method to create the Psi4 input file
        
        """
        # Renaming the molecule as "geometry"
        self.molecule.name = "geometry"
        
        # Get the current working directory, and creating the directory
        # for the Psi4 calculation
        here = os.getcwd()
        work = os.path.join(here, f'Psi4_calculation_{int(time.time())}')
        if os.path.exists(work):
            shutil.rmtree(work)
        os.mkdir(work)
        os.chdir(work)

        # Writing the input file
        inp = os.path.join(work, 'input.json')
        with open(inp, 'w') as f:
            json.dump(self.props, f, indent=4)
        
        # Writing the XYZ file
        self.molecule.save_as_xyz()

        # Writing the Psi4 geometry
        self.psi4_geom += f"""
{self.props['charge']} {self.props['multipl']}\n"""
        
        for a in self.molecule.atoms:
            self.psi4_geom += f'{a.element} {a.coords[0]} {a.coords[1]} {a.coords[2]}\n'
        
        self.psi4_geom += 'units angstrom\n'

        # Switch back to the base directory
        os.chdir(here)

        return work
    
    def run_calculation(self, wd : str) -> None:
        """ Method to run the Psi4 calculation
        
        Parameters
        ----------
        wd : str
            The path of the directory where the Psi4 calculation
            should be performed
        """
        # Create the path to the output file
        out = os.path.join(wd, 'output.out')

        # Get the current working directory
        here = os.getcwd()

        # Switch to the working directory
        os.chdir(wd)

        import psi4

        # Set up an output file
        psi4.set_output_file(out,
                             append=False,
                             loglevel=20,
                             execute=True,
                             print_header=True,
                             inherit_loglevel=False)

        # Set up the geometry
        calc_geom = psi4.geometry(self.psi4_geom)

        # Run the Psi4 calculation
        e, wfn = psi4.energy(f'{self.props["method"]}/{self.props["basis"]}',
                            molecule=calc_geom,
                            return_wfn=True)
        
        psi4.oeprop(wfn,
                    'MULLIKEN_CHARGES',
                    'LOWDIN_CHARGES',
                    title='Psi4 Results')
        
        # Switch back to the base directory
        os.chdir(here)

    def parse_output(self, wd : str) -> dict:
        """ Method to parse the Psi4 results
        
        Parameters
        ----------
        wd : str
            The path of the directory where the Psi4 calculation
            should be performed
        """
        # Create the path to the output file
        out = os.path.join(wd, 'output.out')

        # Empty dictionary to store the results
        results = {}

        # Creating empty Molecule object
        results['Geometry'] = Molecule(self.molecule.name)
        # Loading the information from the XYZ file
        results['Geometry'].read_xyz(os.path.join(wd, 'geometry.xyz'))
        # Creating an empty dictionary for the charges
        results['Charges'] = {}

        # Parse the results
        with open(out, 'r') as f:
            data = f.readlines()
        
        # Iterate over all lines
        for i, l in enumerate(data):

            # Parse the electronic energy
            if ('Total Energy' in l and
                'Computation Completed' in data[i+2]):
                temp = l.split()
                results['Energy[SPE]'] = float(temp[3])

            # Parse the orbital energies
            if 'Orbital Energies [Eh]' in l:

                preCharges = []
                occ = 0.0

                # Iterate over next lines to get the orbital energies
                for j in range(i+1, len(data)):

                    if 'Doubly Occupied:' in data[j]:
                        occ = 2.0
                    if 'Virtual:' in data[j]:
                        occ = 0.0
                    if 'Final Occupation by Irrep:' in data[j]:
                        break

                    orbLine = data[j].split()

                    if len(orbLine) == 6:
                        temp = [[occ,float(orbLine[k])] for k in range(1,6,2)]
                        preCharges += temp

                # Get the orbital charges
                results['OrbitalEnergies[Eh]'] = preCharges
            
            # Parse the Mulliken charges
            if 'Mulliken Charges: (a.u.)' in l:
                results['Charges']['Mulliken'] = []
                for j in range(self.molecule.get_num_atoms()):
                    temp = data[i + 2 + j].split()
                    results['Charges']['Mulliken'].append([
                                                        temp[1],
                                                        float(temp[5])
                                                        ])

            # Parse the Loewding charges
            if 'Lowdin Charges: (a.u.)' in l:
                results['Charges']['Loewdin'] = []
                for j in range(self.molecule.get_num_atoms()):
                    temp = data[i + 2 + j].split()
                    results['Charges']['Loewdin'].append([
                                                        temp[1],
                                                        float(temp[5])
                                                        ])

            # Parse the dipole moment
            if 'Multipole Moments:' in l:

                dipole = []

                # Iterate over next lines to get the dipole moment
                for j in range(i+1, len(data)):

                    if len(dipole) == 3:
                        break

                    if 'Dipole' in data[j]:
                        temp = data[j].split()
                        dipole.append(float(temp[-1]) * 2.5417464519)
                
                # Get the dipole moment
                results['Dipole[Debye]'] = dipole

        return results